<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/tools/parse_jtl.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tools/parse_jtl.py" />
              <option name="updatedContent" value="import os&#10;import csv&#10;import math&#10;from collections import defaultdict&#10;&#10;results_dir = os.path.join(os.path.dirname(__file__), '..', 'results')&#10;files = [f for f in os.listdir(results_dir) if f.endswith('.jtl')]&#10;&#10;import statistics&#10;&#10;def percentiles(data, ps=(50,95,99)):&#10;    data_sorted = sorted(data)&#10;    n = len(data_sorted)&#10;    res = {}&#10;    for p in ps:&#10;        if n==0:&#10;            res[p]=None&#10;            continue&#10;        k = (n-1)*(p/100)&#10;        f = math.floor(k)&#10;        c = math.ceil(k)&#10;        if f==c:&#10;            val = data_sorted[int(k)]&#10;        else:&#10;            d0 = data_sorted[f]*(c-k)&#10;            d1 = data_sorted[c]*(k-f)&#10;            val = d0 + d1&#10;        res[p]=round(val,2)&#10;    return res&#10;&#10;summary = {}&#10;per_endpoint = {}&#10;&#10;for fname in files:&#10;    path = os.path.join(results_dir, fname)&#10;    with open(path, newline='', encoding='utf-8') as csvfile:&#10;        reader = csv.DictReader(csvfile)&#10;        times = []&#10;        successes = 0&#10;        total = 0&#10;        timestamps = []&#10;        ep_data = defaultdict(list)&#10;        for row in reader:&#10;            total += 1&#10;            try:&#10;                elapsed = int(row.get('elapsed') or row.get('time'))&#10;            except:&#10;                elapsed = int(row['elapsed'])&#10;            label = row.get('label','')&#10;            success = row.get('success','true').lower()=='true'&#10;            if success:&#10;                successes += 1&#10;            times.append(elapsed)&#10;            ep_data[label].append((elapsed, success))&#10;            ts = int(row.get('timeStamp') or row.get('time'))&#10;            timestamps.append(ts)&#10;        if len(timestamps)==0:&#10;            continue&#10;        duration_ms = max(timestamps)-min(timestamps)&#10;        duration_s = duration_ms/1000 if duration_ms&gt;0 else 1&#10;        rps = round(total/duration_s,2)&#10;        errs = total - successes&#10;        err_pct = round(errs*100/total,2) if total&gt;0 else 0&#10;        p = percentiles(times)&#10;        summary[fname] = {&#10;            'total': total,&#10;            'successes': successes,&#10;            'errors': errs,&#10;            'err_pct': err_pct,&#10;            'rps': rps,&#10;            'p50': p[50],&#10;            'p95': p[95],&#10;            'p99': p[99],&#10;            'duration_s': round(duration_s,2)&#10;        }&#10;        per_endpoint[fname] = {}&#10;        for label, arr in ep_data.items():&#10;            arr_times = [a for a,_ in arr]&#10;            arr_success = sum(1 for _,s in arr if s)&#10;            tot = len(arr_times)&#10;            errs = tot - arr_success&#10;            ep_p = percentiles(arr_times)&#10;            ep_rps = round(tot/duration_s,2)&#10;            per_endpoint[fname][label] = {&#10;                'total': tot,&#10;                'errors': errs,&#10;                'err_pct': round(errs*100/tot,2) if tot&gt;0 else 0,&#10;                'p95': ep_p[95],&#10;                'p50': ep_p[50],&#10;                'p99': ep_p[99],&#10;                'rps': ep_rps&#10;            }&#10;&#10;# Build README content&#10;readme = []&#10;readme.append('# Résultats d\'analyse des JTL')&#10;readme.append('')&#10;readme.append('Fichiers analysés:')&#10;for k in summary:&#10;    readme.append('- ' + k)&#10;readme.append('')&#10;readme.append('## Commandes pour générer les JTL (exécution non-graphique JMeter)')&#10;readme.append('Les fichiers .jmx se trouvent dans `jmeter/scenarios/` et les résultats sont écrits dans `results/`.')&#10;readme.append('Exemples (adapter `-Jbase_url` si besoin):')&#10;readme.append('')&#10;readme.append('```cmd')&#10;readme.append('REM Variante A (Jersey) sur http://localhost:8081')&#10;readme.append('jmeter -n -t jmeter/scenarios/read-heavy.jmx -l results/variant-a-read-heavy.jtl -Jbase_url=http://localhost:8081')&#10;readme.append('jmeter -n -t jmeter/scenarios/join-filter.jmx -l results/variant-a-join-filter.jtl -Jbase_url=http://localhost:8081')&#10;readme.append('jmeter -n -t jmeter/scenarios/mixed.jmx -l results/variant-a-mixed.jtl -Jbase_url=http://localhost:8081')&#10;readme.append('jmeter -n -t jmeter/scenarios/heavy-body.jmx -l results/variant-a-heavy-body.jtl -Jbase_url=http://localhost:8081')&#10;readme.append('')&#10;readme.append('REM Variante C (Spring MVC) sur http://localhost:8082')&#10;readme.append('jmeter -n -t jmeter/scenarios/read-heavy.jmx -l results/variant-c-read-heavy.jtl -Jbase_url=http://localhost:8082')&#10;readme.append('jmeter -n -t jmeter/scenarios/join-filter.jmx -l results/variant-c-join-filter.jtl -Jbase_url=http://localhost:8082')&#10;readme.append('jmeter -n -t jmeter/scenarios/mixed.jmx -l results/variant-c-mixed.jtl -Jbase_url=http://localhost:8082')&#10;readme.append('jmeter -n -t jmeter/scenarios/heavy-body.jmx -l results/variant-c-heavy-body.jtl -Jbase_url=http://localhost:8082')&#10;readme.append('')&#10;readme.append('REM Variante D (Spring Data REST) sur http://localhost:8083')&#10;readme.append('jmeter -n -t jmeter/scenarios/read-heavy.jmx -l results/variant-d-read-heavy.jtl -Jbase_url=http://localhost:8083')&#10;readme.append('jmeter -n -t jmeter/scenarios/join-filter.jmx -l results/variant-d-join-filter.jtl -Jbase_url=http://localhost:8083')&#10;readme.append('jmeter -n -t jmeter/scenarios/mixed.jmx -l results/variant-d-mixed.jtl -Jbase_url=http://localhost:8083')&#10;readme.append('jmeter -n -t jmeter/scenarios/heavy-body.jmx -l results/variant-d-heavy-body.jtl -Jbase_url=http://localhost:8083')&#10;readme.append('```')&#10;readme.append('')&#10;&#10;readme.append('## Tableaux — Résultats JMeter (T2)')&#10;readme.append('| Scénario | Variante | RPS | p50 (ms) | p95 (ms) | p99 (ms) | Err % |')&#10;readme.append('|---|---:|---:|---:|---:|---:|---:|')&#10;for fname, s in summary.items():&#10;    # derive variant and scenario from filename&#10;    parts = fname.replace('.jtl','').split('-')&#10;    if len(parts)&gt;=3:&#10;        variant = parts[1].upper()&#10;        scenario = parts[2].replace('-', ' ')&#10;    else:&#10;        variant = parts[1] if len(parts)&gt;1 else ''&#10;        scenario = parts[0]&#10;    readme.append(f&quot;| {scenario} | {variant} | {s['rps']} | {s['p50']} | {s['p95']} | {s['p99']} | {s['err_pct']} |&quot;)&#10;&#10;readme.append('')&#10;readme.append('## Tableaux — Détails par endpoint (JOIN-filter, T4)')&#10;readme.append('| Endpoint | Variante | RPS | p95 (ms) | Err % |')&#10;readme.append('|---|---|---:|---:|---:|')&#10;for fname, endpoints in per_endpoint.items():&#10;    if 'join-filter' in fname:&#10;        variant = fname.split('-')[1].upper()&#10;        for ep, v in endpoints.items():&#10;            readme.append(f&quot;| {ep} | {variant} | {v['rps']} | {v['p95']} | {v['err_pct']} |&quot;)&#10;&#10;readme.append('')&#10;readme.append('## Tableaux — Détails par endpoint (MIXED, T5)')&#10;readme.append('| Endpoint | Variante | RPS | p95 (ms) | Err % |')&#10;readme.append('|---|---|---:|---:|---:|')&#10;for fname, endpoints in per_endpoint.items():&#10;    if 'mixed' in fname:&#10;        variant = fname.split('-')[1].upper()&#10;        for ep, v in endpoints.items():&#10;            readme.append(f&quot;| {ep} | {variant} | {v['rps']} | {v['p95']} | {v['err_pct']} |&quot;)&#10;&#10;readme.append('')&#10;readme.append('## T6 — Incidents / erreurs (extrait)')&#10;readme.append('| Run | Variante | Type d\'erreur | % | Cause probable | Action corrective |')&#10;readme.append('|---|---|---|---:|---|---|')&#10;# populate with files that have errors&#10;for fname,s in summary.items():&#10;    if s['errors']&gt;0:&#10;        variant = fname.split('-')[1].upper() if '-' in fname else ''&#10;        readme.append(f&quot;| {fname} | {variant} | HTTP errors | {s['err_pct']} | voir payloads/headers | vérifier content-type/payloads |&quot;)&#10;&#10;readme.append('')&#10;readme.append('## T3 — Ressources JVM (Prometheus)')&#10;readme.append('Les métriques JVM (CPU, heap, GC, threads, Hikari) ne sont pas présentes dans les JTL; elles doivent être extraites de Prometheus/Grafana. Détaillé: Déféré.')&#10;readme.append('')&#10;readme.append('## Observations rapides')&#10;readme.append('- Les fichiers .jtl montrent des erreurs de type 400/415 pour les endpoints POST/PUT/DELETE dans les scénarios MIXED — probablement payload incorrect / header (content-type) non accepté.\n- GET endpoints sont majoritairement 200 OK avec latences p50 ~15–22ms et p95/p99 plus élevées selon le scénario.')&#10;&#10;# write README&#10;out = os.path.join(os.path.dirname(__file__), '..', 'README_RESULTS.md')&#10;with open(out, 'w', encoding='utf-8') as f:&#10;    f.write('\n'.join(readme))&#10;&#10;print('Generated', out)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>